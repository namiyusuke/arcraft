/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 /Users/namikawayuusuke/Desktop/名称未設定フォルダ 9/my-next-project/public/models/dumbbell.glb -o /Users/namikawayuusuke/Desktop/名称未設定フォルダ 9/my-next-project/app/_components/dumbbell.jsx -r public
*/

import React, { useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";

export function DumbbellNew(props) {
  const { nodes, materials } = useGLTF("/models/dumbbell.glb");
  const groupRef = useRef();
  const [isHovered, setIsHovered] = useState(false);
  const [velocity, setVelocity] = useState({ x: 0, y: 0 });
  const lastMousePos = useRef({ x: 0, y: 0 });
  const rotationVelocity = useRef({ x: 0, y: 0, z: 0 });

  // 各メッシュの位置から重心を計算
  const centerX = (0.621 + 0.621 + 0.696) / 3;
  const centerY = (0.429 + 0.388 + 0.388) / 3;
  const centerZ = (0.48 + 0.48 + 0.279) / 3;

  useFrame((state, delta) => {
    if (groupRef.current) {
      if (isHovered) {
        // カーソルがホバー中は速度に基づいて回転
        rotationVelocity.current.x += velocity.y * delta * 10;
        rotationVelocity.current.y += velocity.x * delta * 10;
        rotationVelocity.current.z += (velocity.x + velocity.y) * delta * 5;
      }
      
      // 回転を適用
      groupRef.current.rotation.x += rotationVelocity.current.x * delta;
      groupRef.current.rotation.y += rotationVelocity.current.y * delta;
      groupRef.current.rotation.z += rotationVelocity.current.z * delta;
      
      // 摩擦で速度を減衰
      rotationVelocity.current.x *= 0.95;
      rotationVelocity.current.y *= 0.95;
      rotationVelocity.current.z *= 0.95;
    }
  });

  const handlePointerMove = (event) => {
    const x = (event.clientX / window.innerWidth) * 2 - 1;
    const y = -(event.clientY / window.innerHeight) * 2 + 1;
    
    // マウス速度を計算
    const deltaX = x - lastMousePos.current.x;
    const deltaY = y - lastMousePos.current.y;
    setVelocity({ x: deltaX, y: deltaY });
    
    lastMousePos.current = { x, y };
  };

  const handlePointerEnter = () => {
    setIsHovered(true);
  };

  const handlePointerLeave = () => {
    setIsHovered(false);
    setVelocity({ x: 0, y: 0 });
  };

  return (
    <group
      ref={groupRef}
      {...props}
      dispose={null}
      onPointerMove={handlePointerMove}
      onPointerEnter={handlePointerEnter}
      onPointerLeave={handlePointerLeave}
    >
      <mesh
        geometry={nodes.dumbbell_weights001.geometry}
        material={materials.switch_black}
        position={[0.621 - centerX, 0.429 - centerY, 0.48 - centerZ]}
        rotation={[Math.PI / 2, 0, 0.358]}
        scale={[0.144, 0.045, 0.144]}
      />
      <mesh
        geometry={nodes.dumbbell_parts001.geometry}
        material={materials.bblue}
        position={[0.621 - centerX, 0.388 - centerY, 0.48 - centerZ]}
        rotation={[Math.PI / 2, 0, 0.358]}
        scale={[0.033, 0.052, 0.033]}
      />
      <mesh
        geometry={nodes.dumbbell_bar002.geometry}
        material={materials.metallic_silver}
        position={[0.696 - centerX, 0.388 - centerY, 0.279 - centerZ]}
        rotation={[Math.PI / 2, 0, 0.358]}
        scale={[0.02, 0.409, 0.02]}
      />
    </group>
  );
}

useGLTF.preload("/models/dumbbell.glb");
